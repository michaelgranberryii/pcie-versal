/******************************************************************************
* SPDX-License-Identifier: MIT
*
* Two-Root-Port PCIe Root Complex Enumeration Example
* For Versal + QDMA using xdmapcie standalone driver APIs.
*
* What it does (for each root port):
*  - Initialize driver instance
*  - Disable/clear interrupts
*  - Wait for PCIe link up
*  - Program Root Port Command register (MEM/IO/BUSM/etc.)
*  - Program Primary/Secondary/Subordinate bus numbers (unique per RP)
*  - Enumerate fabric behind that Root Port
*
* NOTE:
*  - Bus ranges must be NON-OVERLAPPING per root port.
*  - Your hardware design must provide non-overlapping MMIO windows if the
*    enumeration code allocates BARs automatically.
******************************************************************************/

#include "xparameters.h"
#include "xdmapcie.h"
#include "xil_printf.h"
#include "sleep.h"

/* Wait for link */
#define LINK_WAIT_MAX_RETRIES        20
#define LINK_WAIT_USLEEP             100000

/* PCI command bits */
#define PCIE_CFG_CMD_IO_EN           0x00000001
#define PCIE_CFG_CMD_MEM_EN          0x00000002
#define PCIE_CFG_CMD_BUSM_EN         0x00000004
#define PCIE_CFG_CMD_PARITY          0x00000040
#define PCIE_CFG_CMD_SERR_EN         0x00000100

/* Config-space WORD offsets used by this driver (same style as your example) */
#define PCIE_CFG_CMD_STATUS_REG      0x0001
#define PCIE_CFG_PRI_SEC_BUS_REG     0x0006

/*
 * Bus numbering encoding
 * The original example used PCIE_CFG_PRIM_SEC_BUS = 0x00070100
 * which corresponds conceptually to prim=0, sec=1, sub=7.
 *
 * So we keep: (sub << 16) | (sec << 8) | (prim << 0)
 */
#define MAKE_BUSNUM(prim, sec, sub)  ( ((u32)(sub) << 16) | ((u32)(sec) << 8) | ((u32)(prim) << 0) )

/* Non-overlapping bus ranges (example) */
#define RP0_BUSNUM_VALUE             MAKE_BUSNUM(0x00, 0x01, 0x7F)  /* buses 0x01..0x7F behind RP0 */
#define RP1_BUSNUM_VALUE             MAKE_BUSNUM(0x00, 0x80, 0xFF)  /* buses 0x80..0xFF behind RP1 */

/* Two instances */
static XDmaPcie Pcie0;
static XDmaPcie Pcie1;

#if defined(QDMA_PCIE_BRIDGE)
extern XDmaPcie_Config XQdmaPcie_ConfigTable[];
#endif

static void PrintRequesterId(XDmaPcie *Inst, const char *tag)
{
    u8 b=0, d=0, f=0, p=0;
    XDmaPcie_GetRequesterId(Inst, &b, &d, &f, &p);
    xil_printf("%s: Bus=%02X Dev=%02X Fun=%02X Port=%02X\r\n", tag, b, d, f, p);
}

#ifndef SDT
static int InitRootPort(XDmaPcie *Inst, u16 DeviceId, u32 BusNums)
#else
static int InitRootPort(XDmaPcie *Inst, UINTPTR BaseAddr, u32 BusNums)
#endif
{
    XDmaPcie_Config *Cfg;
    u32 val;
    u32 intr;
    int ok = 0;

#ifndef SDT
    Cfg = XDmaPcie_LookupConfig(DeviceId);
#else
    Cfg = XDmaPcie_LookupConfig(BaseAddr);
#endif
    if (Cfg == NULL) {
        xil_printf("LookupConfig failed (NULL)\r\n");
        return XST_FAILURE;
    }

#if defined(QDMA_PCIE_BRIDGE)
    /*
     * Some Versal QDMA bridge flows use a fixed config in qdma_config.c
     * instead of the autogenerated xdmapcie_g.c.
     *
     * IMPORTANT:
     * - This indexing assumes DeviceId is 0/1 matching the table order.
     * - If your DeviceIds are not 0/1, donâ€™t use this override; use BaseAddr (SDT)
     *   or map DeviceId->index yourself.
     */
#ifndef SDT
    Cfg = &XQdmaPcie_ConfigTable[DeviceId];
#endif
#endif

    if (XDmaPcie_CfgInitialize(Inst, Cfg, Cfg->BaseAddress) != XST_SUCCESS) {
        xil_printf("CfgInitialize failed\r\n");
        return XST_FAILURE;
    }

    if (!Inst->Config.IncludeRootComplex) {
        xil_printf("This instance is not configured as Root Complex\r\n");
        return XST_FAILURE;
    }

    /* Interrupt hygiene */
    XDmaPcie_GetEnabledInterrupts(Inst, &intr);
    xil_printf("Enabled IRQ mask: 0x%08X\r\n", intr);

    XDmaPcie_DisableInterrupts(Inst, XDMAPCIE_IM_ENABLE_ALL_MASK);

    XDmaPcie_GetPendingInterrupts(Inst, &intr);
    xil_printf("Pending IRQ mask: 0x%08X\r\n", intr);

    XDmaPcie_ClearPendingInterrupts(Inst, XDMAPCIE_ID_CLEAR_ALL_MASK);

    /* Wait for link up */
    for (int r = 0; r < LINK_WAIT_MAX_RETRIES; r++) {
        if (XDmaPcie_IsLinkUp(Inst)) { ok = 1; break; }
        usleep(LINK_WAIT_USLEEP);
    }
    if (!ok) {
        xil_printf("Link is NOT up\r\n");
        return XST_FAILURE;
    }
    xil_printf("Link is up\r\n");
    PrintRequesterId(Inst, "RequesterId");

    /* Program Command register on the Root Port (local config space) */
    XDmaPcie_ReadLocalConfigSpace(Inst, PCIE_CFG_CMD_STATUS_REG, &val);
    val |= (PCIE_CFG_CMD_BUSM_EN |
            PCIE_CFG_CMD_MEM_EN  |
            PCIE_CFG_CMD_IO_EN   |
            PCIE_CFG_CMD_PARITY  |
            PCIE_CFG_CMD_SERR_EN);
    XDmaPcie_WriteLocalConfigSpace(Inst, PCIE_CFG_CMD_STATUS_REG, val);

    XDmaPcie_ReadLocalConfigSpace(Inst, PCIE_CFG_CMD_STATUS_REG, &val);
    xil_printf("Local CMD/STATUS: 0x%08X\r\n", val);

    /* Program bus numbers (Primary/Secondary/Subordinate) on this Root Port */
    XDmaPcie_WriteLocalConfigSpace(Inst, PCIE_CFG_PRI_SEC_BUS_REG, BusNums);
    XDmaPcie_ReadLocalConfigSpace(Inst, PCIE_CFG_PRI_SEC_BUS_REG, &val);
    xil_printf("Local BUS NUMS   : 0x%08X\r\n", val);

    return XST_SUCCESS;
}

int main(void)
{
    int st;

    xil_printf("\r\n=== Versal QDMA: Two Root Ports Enumeration Example ===\r\n");

    /******** Root Port 0 ********/
    xil_printf("\r\n[RP0] Init...\r\n");
#ifndef SDT
    /*
     * Classic flow expects XPAR_*_DEVICE_ID macros.
     * Update these names if your BSP uses different ones.
     */
#ifndef XPAR_XDMAPCIE_0_DEVICE_ID
# error "Missing XPAR_XDMAPCIE_0_DEVICE_ID. If using SDT/Unified, build with SDT and use BASEADDR."
#endif
    st = InitRootPort(&Pcie0, (u16)XPAR_XDMAPCIE_0_DEVICE_ID, RP0_BUSNUM_VALUE);
#else
#ifndef XPAR_XXDMAPCIE_0_BASEADDR
# error "Missing XPAR_XXDMAPCIE_0_BASEADDR. Check your SDT export."
#endif
    st = InitRootPort(&Pcie0, (UINTPTR)XPAR_XXDMAPCIE_0_BASEADDR, RP0_BUSNUM_VALUE);
#endif
    if (st != XST_SUCCESS) {
        xil_printf("[RP0] Init failed\r\n");
        return XST_FAILURE;
    }

    xil_printf("[RP0] Enumerate fabric...\r\n");
    XDmaPcie_EnumerateFabric(&Pcie0);

    /******** Root Port 1 ********/
    xil_printf("\r\n[RP1] Init...\r\n");
#ifndef SDT
#ifndef XPAR_XDMAPCIE_1_DEVICE_ID
# error "Missing XPAR_XDMAPCIE_1_DEVICE_ID. Your design/BSP may not have a second instance."
#endif
    st = InitRootPort(&Pcie1, (u16)XPAR_XDMAPCIE_1_DEVICE_ID, RP1_BUSNUM_VALUE);
#else
#ifndef XPAR_XXDMAPCIE_1_BASEADDR
# error "Missing XPAR_XXDMAPCIE_1_BASEADDR. Your design/BSP may not have a second instance."
#endif
    st = InitRootPort(&Pcie1, (UINTPTR)XPAR_XXDMAPCIE_1_BASEADDR, RP1_BUSNUM_VALUE);
#endif
    if (st != XST_SUCCESS) {
        xil_printf("[RP1] Init failed\r\n");
        return XST_FAILURE;
    }

    xil_printf("[RP1] Enumerate fabric...\r\n");
    XDmaPcie_EnumerateFabric(&Pcie1);

    xil_printf("\r\n=== DONE ===\r\n");
    return XST_SUCCESS;
}
